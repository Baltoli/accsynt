#include <interfind/interfind.h>

#include <fmt/format.h>

#include <llvm/Bitcode/BitcodeWriter.h>
#include <llvm/IR/LLVMContext.h>
#include <llvm/IR/Module.h>
#include <llvm/IRReader/IRReader.h>
#include <llvm/Support/CommandLine.h>
#include <llvm/Support/MemoryBuffer.h>
#include <llvm/Support/raw_ostream.h>
#include <llvm/Support/SourceMgr.h>
#include <llvm/Transforms/Utils/Cloning.h>

#include <nlohmann/json.hpp>

#include <filesystem>
#include <string>

using namespace interfind;
using namespace llvm;
using json = nlohmann::json;
namespace fs = std::filesystem;

/**
 * The input bitcode file to process. Reads from a filename by default, but can
 * be passed '-' as a special case to read from stdin if that's the desired
 * behaviour (e.g. in a pipeline).
 */
cl::opt<std::string> InputFilename(
    cl::Positional, cl::desc("<input file>"), cl::Required);

/**
 * The path of a configuration file specifying how to examine the IR in
 * question. The config is free-form JSON and individual components of InterFind
 * will complain if they don't have the right information passed to them.
 */
cl::opt<std::string> ConfigPath(
    cl::Positional, cl::desc("<config file>"), cl::Required);

/**
 * Silence the analysis output from the tool - if it's silent then any results
 * won't be printed anywhere. This might be useful if you're running the tool
 * in the context of a build system.
 */
cl::opt<bool> Silent(
    "silent", cl::desc("Don't print analysis output anywhere"));
cl::alias SilentShort(
    "s", cl::desc("Alias for -silent"), cl::aliasopt(Silent));

/**
 * Just perform the analysis and output the results without actually changing
 * the bitcode - the tool will act as a pass-through compiler.
 */
cl::opt<bool> AnalysisOnly(
    "analysis-only", cl::desc("Don't modify bitcode - just perform analysis"));
cl::alias AnalysisOnlyShort(
    "A", cl::desc("Alias for -analysis-only"), cl::aliasopt(AnalysisOnly));

/**
 * Where to output the analysis results. The default is to stderr.
 */
cl::opt<std::string> AnalysisOutput(
    "analysis-output", cl::desc("Analysis output filename"), cl::init("-"));
cl::alias AnalysisOutputShort(
    "a", cl::desc("Alias for -analysis-output"), cl::aliasopt(AnalysisOutput));

/**
 * Where to output the modified bitcode generated by the tool. The default is to
 * stdout.
 */
cl::opt<std::string> Output(
    "output", cl::desc("Output bitcode filename"), cl::init("-"));
cl::alias OutputShort(
    "o", cl::desc("Alias for -output"), cl::aliasopt(Output));

int main(int argc, char **argv) try
{
  cl::ParseCommandLineOptions(argc, argv);

  auto ctx = LLVMContext{};
  auto err = SMDiagnostic{};

  auto mod = parseIRFile(InputFilename, err, ctx, true, "");
  if(!mod) {
    err.print(argv[0], errs());
    return 1;
  }

  auto config_path = fs::path(ConfigPath.getValue());
  if(!fs::exists(config_path)) {
    errs() << fmt::format(
      "Config file does not exist: {}\n", config_path.string()
    );

    return 2;
  }

  auto buffer = MemoryBuffer::getFile(config_path.string());
  if(auto err_code = buffer.getError()) {
    errs() << fmt::format(
      "Error opening memory buffer from file: {}\nError: {}\n", 
      config_path.string(),
      err_code.message()
    );
  }

  auto config = json::parse(
    buffer.get()->getBufferStart(), 
    buffer.get()->getBufferEnd());

  auto result = finder::run(*mod, config);
  if(!Silent) {
    if(AnalysisOutput == "-") {
      errs() << fmt::format("{}\n", result);
    } else {
      auto ec = std::error_code{};
      auto fout = raw_fd_ostream(AnalysisOutput, ec);
      if(ec) {
        errs() << fmt::format(
          "Error writing to analysis file: {}\n",
          ec.message()
        );
        return 4;
      }

      fout << fmt::format("{}\n", result);
    }
  }

  auto output_mod = [&] {
    if(AnalysisOnly) {
      return CloneModule(*mod);
    } else {
      return std::move(mod);
    }
  }();

  if(Output == "-") {
    outs() << *output_mod << '\n';
  } else {
    auto ec = std::error_code{};
    auto fout = raw_fd_ostream(Output, ec);
    if(ec) {
      errs() << fmt::format(
        "Error writing to output file: {}\n",
        ec.message()
      );
      return 5;
    }

    WriteBitcodeToFile(*output_mod, fout);
  }
} catch(json::parse_error const& pe) {
  errs() << fmt::format("Error parsing JSON file: {}\n", pe.what());
  std::exit(3);
}
